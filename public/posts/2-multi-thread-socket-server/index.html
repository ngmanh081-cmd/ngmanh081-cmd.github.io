<!doctype html><html lang=en dir=auto data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading | IndieGameDev.HuyManh</title><meta name=keywords content="Java,Concurrency,Thread,Advanced"><meta name=description content="Tại sao Server đơn luồng lại chậm? Hướng dẫn cách sử dụng Thread trong Java để phục vụ nhiều Client cùng lúc mà không bị nghẽn."><meta name=author content="Me"><link rel=canonical href=#ZgotmplZ><link crossorigin=anonymous href=/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as=style><link rel=icon href=#ZgotmplZ><link rel=icon type=image/png sizes=16x16 href=#ZgotmplZ><link rel=icon type=image/png sizes=32x32 href=#ZgotmplZ><link rel=apple-touch-icon href=#ZgotmplZ><link rel=mask-icon href=#ZgotmplZ><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=#ZgotmplZ><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="hhtp://localhost:1313/posts/2-multi-thread-socket-server/"><meta property="og:site_name" content="IndieGameDev.HuyManh"><meta property="og:title" content="Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading"><meta property="og:description" content="Tại sao Server đơn luồng lại chậm? Hướng dẫn cách sử dụng Thread trong Java để phục vụ nhiều Client cùng lúc mà không bị nghẽn."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-24T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Thread"><meta property="article:tag" content="Advanced"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading"><meta name=twitter:description content="Tại sao Server đơn luồng lại chậm? Hướng dẫn cách sử dụng Thread trong Java để phục vụ nhiều Client cùng lúc mà không bị nghẽn."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"hhtp://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading","item":"hhtp://localhost:1313/posts/2-multi-thread-socket-server/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading","name":"Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading","description":"Tại sao Server đơn luồng lại chậm? Hướng dẫn cách sử dụng Thread trong Java để phục vụ nhiều Client cùng lúc mà không bị nghẽn.","keywords":["Java","Concurrency","Thread","Advanced"],"articleBody":"Ở bài trước, chúng ta đã thấy Server đơn luồng (Single-threaded) hoạt động giống như một cửa hàng chỉ có duy nhất một nhân viên. Nếu nhân viên đó đang phục vụ khách A, khách B buộc phải đứng chờ cho đến khi khách A rời đi. Điều này là không thể chấp nhận được trong thực tế.\nGiải pháp là tuyển thêm nhân viên: Mỗi khi có khách hàng mới, ta thuê ngay một nhân viên riêng (Thread) để phục vụ khách đó.\n1. Cơ chế Thread-per-Connection Mô hình này hoạt động như sau:\nMain Thread: Chỉ làm nhiệm vụ đứng ở cửa (Port 6666) và chào đón khách (accept()). Ngay khi khách vào, Main Thread tạo ra một Worker Thread mới. Giao khách đó cho Worker Thread chăm sóc. Main Thread quay lại cửa để đón khách tiếp theo ngay lập tức. 2. Code triển khai Multi-threaded Server Chúng ta sẽ tách phần xử lý logic ra một class riêng gọi là ServerThread thực thi interface Runnable.\nimport java.io.*; import java.net.*; public class MultiThreadServer { public static void main(String[] args) { int port = 6666; try (ServerSocket serverSocket = new ServerSocket(port)) { System.out.println(\"Server Đa luồng đang chạy tại cổng \" + port); while (true) { // 1. Chấp nhận kết nối Socket socket = serverSocket.accept(); System.out.println(\"Client mới kết nối: \" + socket.getInetAddress()); // 2. Thay vì xử lý ngay, ta tạo một luồng mới // và ném socket đó vào cho luồng xử lý ServerThread worker = new ServerThread(socket); // 3. Khởi chạy luồng (nhân viên bắt đầu làm việc) new Thread(worker).start(); } } catch (IOException ex) { ex.printStackTrace(); } } } // Class nhân viên xử lý riêng biệt class ServerThread implements Runnable { private Socket socket; public ServerThread(Socket socket) { this.socket = socket; } @Override public void run() { try { InputStream input = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(input)); OutputStream output = socket.getOutputStream(); PrintWriter writer = new PrintWriter(output, true); String text; // Vòng lặp giao tiếp riêng với client này while ((text = reader.readLine()) != null) { System.out.println(\"[\" + Thread.currentThread().getName() + \"] Nhận: \" + text); writer.println(\"Server trả lời: \" + text); if (\"bye\".equalsIgnoreCase(text)) { break; } } socket.close(); } catch (IOException ex) { System.out.println(\"Lỗi kết nối ServerThread: \" + ex.getMessage()); } } } ","wordCount":"380","inLanguage":"en","datePublished":"2025-12-24T00:00:00Z","dateModified":"2025-12-24T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"hhtp://localhost:1313/posts/2-multi-thread-socket-server/"},"publisher":{"@type":"Organization","name":"IndieGameDev.HuyManh","logo":{"@type":"ImageObject","url":"hhtp://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=#ZgotmplZ accesskey=h title="IndieGameDev.HuyManh (Alt + H)">IndieGameDev.HuyManh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=#ZgotmplZ title="Trang chủ"><span>Trang chủ</span></a></li><li><a href=#ZgotmplZ title="Bài viết"><span>Bài viết</span></a></li><li><a href=#ZgotmplZ title="Giới thiệu"><span>Giới thiệu</span></a></li><li><a href=#ZgotmplZ title="Liên hệ"><span>Liên hệ</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Tối ưu hóa Server: Xử lý hàng ngàn kết nối với Multi-threading</h1><div class=post-meta><span title='2025-12-24 00:00:00 +0000 UTC'>December 24, 2025</span>&nbsp;·&nbsp;<span>Me</span></div></header><div class=post-content><p>Ở bài trước, chúng ta đã thấy Server đơn luồng (Single-threaded) hoạt động giống như một cửa hàng chỉ có duy nhất một nhân viên. Nếu nhân viên đó đang phục vụ khách A, khách B buộc phải đứng chờ cho đến khi khách A rời đi. Điều này là không thể chấp nhận được trong thực tế.</p><p>Giải pháp là tuyển thêm nhân viên: Mỗi khi có khách hàng mới, ta thuê ngay một nhân viên riêng (Thread) để phục vụ khách đó.</p><h2 id=1-cơ-chế-thread-per-connection>1. Cơ chế Thread-per-Connection<a hidden class=anchor aria-hidden=true href=#1-cơ-chế-thread-per-connection>#</a></h2><p>Mô hình này hoạt động như sau:</p><ol><li><strong>Main Thread:</strong> Chỉ làm nhiệm vụ đứng ở cửa (Port 6666) và chào đón khách (<code>accept()</code>).</li><li>Ngay khi khách vào, Main Thread tạo ra một <strong>Worker Thread</strong> mới.</li><li>Giao khách đó cho Worker Thread chăm sóc.</li><li>Main Thread quay lại cửa để đón khách tiếp theo ngay lập tức.</li></ol><h2 id=2-code-triển-khai-multi-threaded-server>2. Code triển khai Multi-threaded Server<a hidden class=anchor aria-hidden=true href=#2-code-triển-khai-multi-threaded-server>#</a></h2><p>Chúng ta sẽ tách phần xử lý logic ra một class riêng gọi là <code>ServerThread</code> thực thi interface <code>Runnable</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiThreadServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> 6666;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ServerSocket serverSocket <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerSocket(port)) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Server Đa luồng đang chạy tại cổng &#34;</span> <span style=color:#f92672>+</span> port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 1. Chấp nhận kết nối</span>
</span></span><span style=display:flex><span>                Socket socket <span style=color:#f92672>=</span> serverSocket.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Client mới kết nối: &#34;</span> <span style=color:#f92672>+</span> socket.<span style=color:#a6e22e>getInetAddress</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 2. Thay vì xử lý ngay, ta tạo một luồng mới</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// và ném socket đó vào cho luồng xử lý</span>
</span></span><span style=display:flex><span>                ServerThread worker <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerThread(socket);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 3. Khởi chạy luồng (nhân viên bắt đầu làm việc)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> Thread(worker).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException ex) {
</span></span><span style=display:flex><span>            ex.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Class nhân viên xử lý riêng biệt</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerThread</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Socket socket;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ServerThread</span>(Socket socket) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>socket</span> <span style=color:#f92672>=</span> socket;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            InputStream input <span style=color:#f92672>=</span> socket.<span style=color:#a6e22e>getInputStream</span>();
</span></span><span style=display:flex><span>            BufferedReader reader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(input));
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            OutputStream output <span style=color:#f92672>=</span> socket.<span style=color:#a6e22e>getOutputStream</span>();
</span></span><span style=display:flex><span>            PrintWriter writer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PrintWriter(output, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            String text;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Vòng lặp giao tiếp riêng với client này</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> ((text <span style=color:#f92672>=</span> reader.<span style=color:#a6e22e>readLine</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] Nhận: &#34;</span> <span style=color:#f92672>+</span> text);
</span></span><span style=display:flex><span>                writer.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Server trả lời: &#34;</span> <span style=color:#f92672>+</span> text);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;bye&#34;</span>.<span style=color:#a6e22e>equalsIgnoreCase</span>(text)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            socket.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException ex) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Lỗi kết nối ServerThread: &#34;</span> <span style=color:#f92672>+</span> ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=#ZgotmplZ>Java</a></li><li><a href=#ZgotmplZ>Concurrency</a></li><li><a href=#ZgotmplZ>Thread</a></li><li><a href=#ZgotmplZ>Advanced</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=#ZgotmplZ>IndieGameDev.HuyManh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>