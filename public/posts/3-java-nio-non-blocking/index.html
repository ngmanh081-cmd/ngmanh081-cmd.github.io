<!doctype html><html lang=en dir=auto data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java NIO: Bí mật đằng sau các High-Performance Server | IndieGameDev.HuyManh</title><meta name=keywords content="Java,NIO,Netty,Architecture"><meta name=description content="Phân tích sự khác biệt giữa Blocking IO và Non-Blocking IO. Tại sao Node.js hay Netty lại nhanh đến vậy?"><meta name=author content="Me"><link rel=canonical href=#ZgotmplZ><link crossorigin=anonymous href=/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as=style><link rel=icon href=#ZgotmplZ><link rel=icon type=image/png sizes=16x16 href=#ZgotmplZ><link rel=icon type=image/png sizes=32x32 href=#ZgotmplZ><link rel=apple-touch-icon href=#ZgotmplZ><link rel=mask-icon href=#ZgotmplZ><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=#ZgotmplZ><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="hhtp://localhost:1313/posts/3-java-nio-non-blocking/"><meta property="og:site_name" content="IndieGameDev.HuyManh"><meta property="og:title" content="Java NIO: Bí mật đằng sau các High-Performance Server"><meta property="og:description" content="Phân tích sự khác biệt giữa Blocking IO và Non-Blocking IO. Tại sao Node.js hay Netty lại nhanh đến vậy?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-23T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="NIO"><meta property="article:tag" content="Netty"><meta property="article:tag" content="Architecture"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java NIO: Bí mật đằng sau các High-Performance Server"><meta name=twitter:description content="Phân tích sự khác biệt giữa Blocking IO và Non-Blocking IO. Tại sao Node.js hay Netty lại nhanh đến vậy?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"hhtp://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Java NIO: Bí mật đằng sau các High-Performance Server","item":"hhtp://localhost:1313/posts/3-java-nio-non-blocking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java NIO: Bí mật đằng sau các High-Performance Server","name":"Java NIO: Bí mật đằng sau các High-Performance Server","description":"Phân tích sự khác biệt giữa Blocking IO và Non-Blocking IO. Tại sao Node.js hay Netty lại nhanh đến vậy?","keywords":["Java","NIO","Netty","Architecture"],"articleBody":"Nếu bạn thắc mắc tại sao Node.js (đơn luồng) lại có thể xử lý hàng chục nghìn kết nối đồng thời, hay tại sao các framework Java hiện đại như Netty, Vert.x lại có hiệu năng vượt trội so với Tomcat truyền thống, thì câu trả lời nằm ở: Non-blocking I/O (NIO).\nTrong Java, gói thư viện này nằm ở java.nio (được giới thiệu từ Java 1.4).\n1. IO Truyền thống (BIO) vs NIO BIO (Blocking I/O) - Mô hình cũ Như các bài trước, BIO dựa trên Stream (Luồng dữ liệu).\nKhi gọi input.read(), Thread bị chặn (block) cho đến khi có dữ liệu. Hệ quả: Cần 1 Thread cho mỗi kết nối. 10k kết nối = 10k Threads. Rất tốn kém. NIO (Non-blocking I/O) - Mô hình mới NIO dựa trên Buffer (Vùng nhớ) và Channel (Kênh).\nKhi gọi đọc dữ liệu, nếu chưa có dữ liệu, nó trả về ngay lập tức thay vì bắt chờ đợi. Thread đó có thể đi làm việc khác. Hệ quả: Chỉ cần 1 Thread duy nhất có thể quản lý 10k kết nối. 2. Ba trụ cột của Java NIO Để hiểu NIO, bạn cần nắm 3 khái niệm:\nBuffer: Là một vùng nhớ (block of memory) để chứa dữ liệu đọc/ghi. Trong NIO, bạn luôn đọc từ Channel vào Buffer, hoặc ghi từ Buffer ra Channel. Channel: Giống như Socket nhưng là đường 2 chiều (có thể vừa đọc vừa ghi). Quan trọng nhất là nó hỗ trợ chế độ phi đồng bộ (asynchronous). Selector (Bộ chọn): Đây là “nhạc trưởng”. Một Selector có thể giám sát hàng trăm Channel. Khi nào Channel nào có dữ liệu (“Hey, tôi có tin nhắn mới!”), Selector sẽ báo cho Thread xử lý. 3. Code ví dụ: NIO Echo Server Code NIO phức tạp hơn BIO rất nhiều, nhưng “đắt xắt ra miếng”.\nimport java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; import java.util.Set; public class NioServer { public static void main(String[] args) throws IOException { // 1. Mở Selector Selector selector = Selector.open(); // 2. Mở ServerSocketChannel (thay vì ServerSocket thường) ServerSocketChannel serverSocket = ServerSocketChannel.open(); serverSocket.bind(new InetSocketAddress(\"localhost\", 6666)); // QUAN TRỌNG: Cấu hình chế độ Non-blocking serverSocket.configureBlocking(false); // 3. Đăng ký kênh server với Selector, lắng nghe sự kiện ACCEPT (kết nối mới) serverSocket.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"NIO Server đang chạy...\"); while (true) { // Chờ cho đến khi có ít nhất 1 sự kiện xảy ra selector.select(); // Lấy danh sách các kênh đang kích hoạt (có sự kiện) Set\u003cSelectionKey\u003e selectedKeys = selector.selectedKeys(); Iterator\u003cSelectionKey\u003e iter = selectedKeys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); if (key.isAcceptable()) { // Sự kiện: Có client mới kết nối register(selector, serverSocket); } if (key.isReadable()) { // Sự kiện: Có dữ liệu gửi đến để đọc answerWithEcho(key); } // Xử lý xong thì xóa key khỏi danh sách để tránh lặp lại iter.remove(); } } } private static void register(Selector selector, ServerSocketChannel serverSocket) throws IOException { SocketChannel client = serverSocket.accept(); client.configureBlocking(false); // Client này cũng phải Non-blocking client.register(selector, SelectionKey.OP_READ); // Chỉ quan tâm khi nào nó gửi tin nhắn System.out.println(\"Client mới kết nối: \" + client.getRemoteAddress()); } private static void answerWithEcho(SelectionKey key) throws IOException { SocketChannel client = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(256); // Tạo vùng đệm 256 bytes int r = client.read(buffer); if (r == -1) { client.close(); // Client đã ngắt kết nối System.out.println(\"Client ngắt kết nối.\"); } else { // Chuyển chế độ Buffer từ ghi sang đọc buffer.flip(); // Ghi dữ liệu từ Buffer trả ngược lại Client (Echo) client.write(buffer); buffer.clear(); } } } ","wordCount":"593","inLanguage":"en","datePublished":"2025-12-23T00:00:00Z","dateModified":"2025-12-23T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"hhtp://localhost:1313/posts/3-java-nio-non-blocking/"},"publisher":{"@type":"Organization","name":"IndieGameDev.HuyManh","logo":{"@type":"ImageObject","url":"hhtp://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=#ZgotmplZ accesskey=h title="IndieGameDev.HuyManh (Alt + H)">IndieGameDev.HuyManh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=#ZgotmplZ title="Trang chủ"><span>Trang chủ</span></a></li><li><a href=#ZgotmplZ title="Bài viết"><span>Bài viết</span></a></li><li><a href=#ZgotmplZ title="Giới thiệu"><span>Giới thiệu</span></a></li><li><a href=#ZgotmplZ title="Liên hệ"><span>Liên hệ</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Java NIO: Bí mật đằng sau các High-Performance Server</h1><div class=post-meta><span title='2025-12-23 00:00:00 +0000 UTC'>December 23, 2025</span>&nbsp;·&nbsp;<span>Me</span></div></header><div class=post-content><p>Nếu bạn thắc mắc tại sao <strong>Node.js</strong> (đơn luồng) lại có thể xử lý hàng chục nghìn kết nối đồng thời, hay tại sao các framework Java hiện đại như <strong>Netty</strong>, <strong>Vert.x</strong> lại có hiệu năng vượt trội so với Tomcat truyền thống, thì câu trả lời nằm ở: <strong>Non-blocking I/O (NIO)</strong>.</p><p>Trong Java, gói thư viện này nằm ở <code>java.nio</code> (được giới thiệu từ Java 1.4).</p><h2 id=1-io-truyền-thống-bio-vs-nio>1. IO Truyền thống (BIO) vs NIO<a hidden class=anchor aria-hidden=true href=#1-io-truyền-thống-bio-vs-nio>#</a></h2><h3 id=bio-blocking-io---mô-hình-cũ>BIO (Blocking I/O) - Mô hình cũ<a hidden class=anchor aria-hidden=true href=#bio-blocking-io---mô-hình-cũ>#</a></h3><p>Như các bài trước, BIO dựa trên <strong>Stream</strong> (Luồng dữ liệu).</p><ul><li>Khi gọi <code>input.read()</code>, Thread bị chặn (block) cho đến khi có dữ liệu.</li><li><strong>Hệ quả:</strong> Cần 1 Thread cho mỗi kết nối. 10k kết nối = 10k Threads. Rất tốn kém.</li></ul><h3 id=nio-non-blocking-io---mô-hình-mới>NIO (Non-blocking I/O) - Mô hình mới<a hidden class=anchor aria-hidden=true href=#nio-non-blocking-io---mô-hình-mới>#</a></h3><p>NIO dựa trên <strong>Buffer</strong> (Vùng nhớ) và <strong>Channel</strong> (Kênh).</p><ul><li>Khi gọi đọc dữ liệu, nếu chưa có dữ liệu, nó trả về ngay lập tức thay vì bắt chờ đợi. Thread đó có thể đi làm việc khác.</li><li><strong>Hệ quả:</strong> Chỉ cần <strong>1 Thread duy nhất</strong> có thể quản lý 10k kết nối.</li></ul><h2 id=2-ba-trụ-cột-của-java-nio>2. Ba trụ cột của Java NIO<a hidden class=anchor aria-hidden=true href=#2-ba-trụ-cột-của-java-nio>#</a></h2><p>Để hiểu NIO, bạn cần nắm 3 khái niệm:</p><ol><li><strong>Buffer:</strong> Là một vùng nhớ (block of memory) để chứa dữ liệu đọc/ghi. Trong NIO, bạn luôn đọc từ Channel vào Buffer, hoặc ghi từ Buffer ra Channel.</li><li><strong>Channel:</strong> Giống như Socket nhưng là đường 2 chiều (có thể vừa đọc vừa ghi). Quan trọng nhất là nó hỗ trợ chế độ phi đồng bộ (asynchronous).</li><li><strong>Selector (Bộ chọn):</strong> Đây là &ldquo;nhạc trưởng&rdquo;. Một Selector có thể giám sát hàng trăm Channel. Khi nào Channel nào có dữ liệu (&ldquo;Hey, tôi có tin nhắn mới!&rdquo;), Selector sẽ báo cho Thread xử lý.</li></ol><h2 id=3-code-ví-dụ-nio-echo-server>3. Code ví dụ: NIO Echo Server<a hidden class=anchor aria-hidden=true href=#3-code-ví-dụ-nio-echo-server>#</a></h2><p>Code NIO phức tạp hơn BIO rất nhiều, nhưng &ldquo;đắt xắt ra miếng&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.InetSocketAddress;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.ByteBuffer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.channels.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Iterator;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Set;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. Mở Selector</span>
</span></span><span style=display:flex><span>        Selector selector <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. Mở ServerSocketChannel (thay vì ServerSocket thường)</span>
</span></span><span style=display:flex><span>        ServerSocketChannel serverSocket <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>        serverSocket.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(<span style=color:#e6db74>&#34;localhost&#34;</span>, 6666));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// QUAN TRỌNG: Cấu hình chế độ Non-blocking</span>
</span></span><span style=display:flex><span>        serverSocket.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. Đăng ký kênh server với Selector, lắng nghe sự kiện ACCEPT (kết nối mới)</span>
</span></span><span style=display:flex><span>        serverSocket.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_ACCEPT</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;NIO Server đang chạy...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Chờ cho đến khi có ít nhất 1 sự kiện xảy ra</span>
</span></span><span style=display:flex><span>            selector.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Lấy danh sách các kênh đang kích hoạt (có sự kiện)</span>
</span></span><span style=display:flex><span>            Set<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> selectedKeys <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>();
</span></span><span style=display:flex><span>            Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> selectedKeys.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Sự kiện: Có client mới kết nối</span>
</span></span><span style=display:flex><span>                    register(selector, serverSocket);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Sự kiện: Có dữ liệu gửi đến để đọc</span>
</span></span><span style=display:flex><span>                    answerWithEcho(key);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Xử lý xong thì xóa key khỏi danh sách để tránh lặp lại</span>
</span></span><span style=display:flex><span>                iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>register</span>(Selector selector, ServerSocketChannel serverSocket) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        SocketChannel client <span style=color:#f92672>=</span> serverSocket.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>        client.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// Client này cũng phải Non-blocking</span>
</span></span><span style=display:flex><span>        client.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_READ</span>); <span style=color:#75715e>// Chỉ quan tâm khi nào nó gửi tin nhắn</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Client mới kết nối: &#34;</span> <span style=color:#f92672>+</span> client.<span style=color:#a6e22e>getRemoteAddress</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>answerWithEcho</span>(SelectionKey key) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        SocketChannel client <span style=color:#f92672>=</span> (SocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>        ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(256); <span style=color:#75715e>// Tạo vùng đệm 256 bytes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> client.<span style=color:#a6e22e>read</span>(buffer);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#f92672>-</span>1) {
</span></span><span style=display:flex><span>            client.<span style=color:#a6e22e>close</span>(); <span style=color:#75715e>// Client đã ngắt kết nối</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Client ngắt kết nối.&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Chuyển chế độ Buffer từ ghi sang đọc</span>
</span></span><span style=display:flex><span>            buffer.<span style=color:#a6e22e>flip</span>(); 
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Ghi dữ liệu từ Buffer trả ngược lại Client (Echo)</span>
</span></span><span style=display:flex><span>            client.<span style=color:#a6e22e>write</span>(buffer);
</span></span><span style=display:flex><span>            buffer.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=#ZgotmplZ>Java</a></li><li><a href=#ZgotmplZ>NIO</a></li><li><a href=#ZgotmplZ>Netty</a></li><li><a href=#ZgotmplZ>Architecture</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=#ZgotmplZ>IndieGameDev.HuyManh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>